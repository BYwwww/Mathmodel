% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
%Dijkstra算法介绍：求一个源点到其他各顶点的最短路径
%               
% 变量设置
% （1） 结点个数n； 
% （2）二维矩阵M（nxn），距离矩阵，连通的结点间即为距离，不连通的结点间为正无穷，和自己的距离为0； 
% （3）一维矩阵pb（1xn），若第i点已找到最短路径，则pb（i）=1，否则等于0，对于初始结点，pb=1； 
% （4）距离矩阵d（1xn），若第i点已找到最短路径，则的d（i）=最短距离，否则为0，初始结点d=0； 
% （5）上一结点矩阵path（1xn)，若第i点找到了最短路径，则path存放这一条最短路径的前一个结点，通过对每一点的回溯，可以找到最短路径。

% 方法说明：
% size(a)表示矩阵每个维度的长度，即几行几列（size([1 2 3;4 5 6]) = [2,3]）
% length(a)表示矩阵a的最大的长度，即max(size(a)),length([1 2 3;4 5 6])等于3，因为2和3中最大是3
% Inf表示无穷大
% find（条件）表示找到符合条件的元素的下标，返回下标的集合
% 
% 该函数使用方法：
% 输入：要求的最短距离的矩阵，下例矩阵为m
% 输出：d:起点到任何点的最短路径的距离集合
%       path:存放这一条最短路径的前一个结点的集合，通过回溯可得到最短的具体路径
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 




clc;clear;
%定义n阶零矩阵
m = [0,6,Inf,Inf,Inf,2;
    6,0,2,Inf,Inf,1;
    Inf,2,0,4,1,5;
    Inf,Inf,4,0,1,Inf;
    Inf,Inf,1,1,0,7;
    2,1,5,Inf,7,0];

n=6;   %设置矩阵大小
temp=1;  %设置起始点

pb(1:length(m))=0;pb(temp)=1;%求出最短路径的点为1，未求出的为0
% 或者pb = [1,0,0,0,0,0];

d(1:length(m))=0;%存放各点的最短距离
% 或者d = [0,0,0,0,0,0];

path(1:length(m))=0;%存放各点最短路径的上一点标号
% 或者path = [0,0,0,0,0,0];

while sum(pb)<n %判断每一点是否都已找到最短路径
 tb=find(pb==0);%找到还未找到最短路径的点
 fb=find(pb);%找出已找到最短路径的点
 min=inf;
 for i=1:length(fb)
     for j=1:length(tb)
         plus=d(fb(i))+m(fb(i),tb(j));  %比较已确定的点与其相邻未确定点的距离
         if((d(fb(i))+m(fb(i),tb(j)))<min)
             min=d(fb(i))+m(fb(i),tb(j));
             lastpoint=fb(i);
             newpoint=tb(j);
         end
     end
 end
 d(newpoint)=min;
 pb(newpoint)=1;
 path(newpoint)=lastpoint; %最小值时的与之连接点
end
fprintf('距离矩阵：%d');
m

fprintf('已找到最短路径的点的集合');
pb

fprintf('已找到最短路径的总距离');
d

fprintf('已找到最短路径的距离（往前回溯）');
path
